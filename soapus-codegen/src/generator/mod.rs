//! Code generation module for SOAP clients
//!
//! This module transforms parsed WSDL and XSD models into Rust code.

pub mod rust_codegen;
pub mod type_mapper;

use crate::error::Result;
use crate::parser::{WsdlModel, XmlSchema};
use crate::SoapClientGenerator;

#[cfg(feature = "tracing")]
use tracing::{debug, info};

/// Generate complete SOAP client code from WSDL model
pub fn generate_client_code(wsdl: &WsdlModel, config: &SoapClientGenerator) -> Result<String> {
    #[cfg(feature = "tracing")]
    info!(
        service_name = ?wsdl.service_name(),
        "Starting code generation"
    );

    let mut generator = CodeGenerator::new(wsdl, config);
    let result = generator.generate();

    #[cfg(feature = "tracing")]
    match &result {
        Ok(code) => info!(
            code_size = code.len(),
            "Code generation completed successfully"
        ),
        Err(e) => tracing::error!(error = %e, "Code generation failed"),
    }

    result
}

/// Main code generator that orchestrates the generation process
pub struct CodeGenerator<'a> {
    wsdl: &'a WsdlModel,
    config: &'a SoapClientGenerator,
    type_mapper: type_mapper::TypeMapper,
}

impl<'a> CodeGenerator<'a> {
    /// Create a new code generator
    pub fn new(wsdl: &'a WsdlModel, config: &'a SoapClientGenerator) -> Self {
        Self {
            wsdl,
            config,
            type_mapper: type_mapper::TypeMapper::new(),
        }
    }

    /// Generate the complete client code
    pub fn generate(&mut self) -> Result<String> {
        let mut output = String::new();

        // File header and imports
        #[cfg(feature = "tracing")]
        debug!("Generating file header and imports");
        output.push_str(&self.generate_header());
        output.push_str("\n\n");

        // Generate types from XSD schema
        if let Some(schema) = self.wsdl.schema() {
            #[cfg(feature = "tracing")]
            debug!("Generating types from XSD schema");
            output.push_str(&self.generate_types(schema)?);
            output.push_str("\n\n");
        }

        // Generate client struct and implementation
        #[cfg(feature = "tracing")]
        debug!("Generating client struct");
        output.push_str(&self.generate_client_struct()?);
        output.push_str("\n\n");

        // Generate operation methods
        #[cfg(feature = "tracing")]
        debug!(
            operation_count = self.wsdl.operations().count(),
            "Generating operation methods"
        );
        output.push_str(&self.generate_operations()?);
        output.push_str("\n\n");

        // Generate tests if enabled
        if self.config.generate_tests() {
            #[cfg(feature = "tracing")]
            debug!("Generating test code");
            output.push_str(&self.generate_tests()?);
            output.push('\n');
        }

        Ok(output)
    }

    /// Generate file header with imports
    fn generate_header(&self) -> String {
        let namespace = self
            .wsdl
            .target_namespace()
            .unwrap_or("http://tempuri.org/");

        format!(
            r#"// This file is automatically generated from WSDL.
// DO NOT EDIT - your changes will be overwritten!

use serde::{{Serialize, Deserialize}};
use soapus_runtime::{{SoapClient, SoapResult}};

/// Target namespace from WSDL
pub const TARGET_NAMESPACE: &str = "{}";

"#,
            namespace
        )
    }

    /// Generate Rust structs from XSD schema
    /// Generate types from XSD schema
    fn generate_types(&self, schema: &XmlSchema) -> Result<String> {
        let mut output = String::new();

        // Generate ComplexTypes as structs
        #[cfg(feature = "tracing")]
        debug!(
            complex_type_count = schema.complex_types.len(),
            "Generating complex types"
        );
        for (name, complex_type) in &schema.complex_types {
            output.push_str(&rust_codegen::generate_complex_type(
                name,
                complex_type,
                &self.type_mapper,
            )?);
            output.push_str("\n\n");
        }

        // Generate SimpleTypes as enums (if they have enumerations)
        #[cfg(feature = "tracing")]
        debug!(
            simple_type_count = schema.simple_types.len(),
            "Generating simple types"
        );
        for (name, simple_type) in &schema.simple_types {
            if let Some(enum_code) = rust_codegen::generate_simple_type_enum(name, simple_type)? {
                output.push_str(&enum_code);
                output.push_str("\n\n");
            }
        }

        Ok(output)
    }

    /// Generate the main client struct
    fn generate_client_struct(&self) -> Result<String> {
        let client_name = self
            .config
            .client_name()
            .unwrap_or_else(|| self.wsdl.service_name().unwrap_or("SoapServiceClient"));

        let struct_def = format!(
            r#"/// SOAP client for {}
#[derive(Debug, Clone)]
pub struct {} {{
    client: SoapClient,
}}

impl {} {{
    /// Create a new SOAP client with the given endpoint URL
    pub fn new(endpoint: impl Into<String>) -> Self {{
        Self {{
            client: SoapClient::new(endpoint),
        }}
    }}

    /// Create a new SOAP client with custom configuration
    pub fn with_client(client: SoapClient) -> Self {{
        Self {{ client }}
    }}

    /// Get a reference to the underlying SOAP client
    pub fn client(&self) -> &SoapClient {{
        &self.client
    }}

    /// Get a mutable reference to the underlying SOAP client
    pub fn client_mut(&mut self) -> &mut SoapClient {{
        &mut self.client
    }}
}}"#,
            client_name, client_name, client_name
        );

        Ok(struct_def)
    }

    /// Generate operation methods
    fn generate_operations(&self) -> Result<String> {
        let mut output = String::new();

        let client_name = self
            .config
            .client_name()
            .unwrap_or_else(|| self.wsdl.service_name().unwrap_or("SoapServiceClient"));

        let service_name = self.wsdl.service_name().unwrap_or("SoapService");

        output.push_str(&format!("impl {} {{\n", client_name));

        // Generate operation methods
        for operation in self.wsdl.operations() {
            let method_code =
                rust_codegen::generate_operation_method(operation, self.wsdl, &self.type_mapper)?;
            // Replace service name placeholder
            let method_code = method_code.replace("{{service_name}}", service_name);
            output.push_str(&method_code);
            output.push('\n');
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate test code
    fn generate_tests(&self) -> Result<String> {
        let mut output = String::new();

        output.push_str("#[cfg(test)]\nmod tests {\n");
        output.push_str("    use super::*;\n\n");

        output.push_str("    #[test]\n");
        output.push_str("    fn test_client_creation() {\n");
        output.push_str("        let client = ");

        let client_name = self
            .config
            .client_name()
            .unwrap_or_else(|| self.wsdl.service_name().unwrap_or("SoapServiceClient"));

        output.push_str(client_name);
        output.push_str("::new(\"http://example.com/service\");\n");
        output.push_str(
            "        assert_eq!(client.client().endpoint(), \"http://example.com/service\");\n",
        );
        output.push_str("    }\n\n");

        // Generate type serialization tests
        output.push_str("    // Add your own tests here\n");

        output.push_str("}\n");

        Ok(output)
    }
}

/// Helper to sanitize names for Rust identifiers
pub fn sanitize_identifier(name: &str) -> String {
    let mut result = String::new();

    for ch in name.chars() {
        if ch.is_alphanumeric() || ch == '_' {
            result.push(ch);
        } else if ch == '-' || ch == '.' {
            // Replace invalid chars with underscore
            result.push('_');
        }
        // Skip other invalid characters
    }

    // Ensure it doesn't start with a number
    if result.is_empty() {
        result.push('_');
    } else if result.chars().next().is_some_and(|c| c.is_numeric()) {
        result.insert(0, '_');
    }

    // Check if it's a Rust keyword and escape if needed
    match result.as_str() {
        "type" | "mod" | "fn" | "struct" | "enum" | "trait" | "impl" | "use" | "as" | "ref"
        | "mut" | "const" | "static" | "let" | "match" | "if" | "else" | "while" | "for"
        | "loop" | "return" | "break" | "continue" | "async" | "await" | "move" | "self"
        | "Self" | "super" | "crate" | "pub" | "in" | "where" => {
            format!("r#{}", result)
        }
        _ => result,
    }
}

/// Convert snake_case or kebab-case to PascalCase
pub fn to_pascal_case(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for ch in name.chars() {
        if ch.is_alphanumeric() {
            if capitalize_next {
                result.push_str(&ch.to_uppercase().to_string());
                capitalize_next = false;
            } else {
                result.push(ch);
            }
        } else {
            capitalize_next = true;
        }
    }

    result
}

/// Convert PascalCase or kebab-case to snake_case
pub fn to_snake_case(name: &str) -> String {
    let mut result = String::new();
    let mut prev_is_lower = false;

    for (i, ch) in name.chars().enumerate() {
        if ch == '-' || ch == '.' {
            result.push('_');
            prev_is_lower = false;
        } else if ch.is_uppercase() {
            if i > 0 && prev_is_lower {
                result.push('_');
            }
            result.push_str(&ch.to_lowercase().to_string());
            prev_is_lower = false;
        } else {
            result.push(ch);
            prev_is_lower = ch.is_lowercase();
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_identifier() {
        assert_eq!(sanitize_identifier("my-field"), "my_field");
        assert_eq!(sanitize_identifier("my_field"), "my_field");
        assert_eq!(sanitize_identifier("123field"), "_123field");
        assert_eq!(sanitize_identifier("type"), "r#type");
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("my_type"), "MyType");
        assert_eq!(to_pascal_case("my-type"), "MyType");
        assert_eq!(to_pascal_case("myType"), "MyType");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("MyType"), "my_type");
        assert_eq!(to_snake_case("myType"), "my_type");
        assert_eq!(to_snake_case("my-type"), "my_type");
    }
}
